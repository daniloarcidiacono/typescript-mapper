package io.github.daniloarcidiacono.typescript.mapper;

import io.github.daniloarcidiacono.commons.lang.FileCommons;
import io.github.daniloarcidiacono.typescript.mapper.mapper.TypescriptMapped;
import io.github.daniloarcidiacono.typescript.mapper.mapper.TypescriptMappedComparator;
import io.github.daniloarcidiacono.typescript.mapper.renderer.TypescriptRenderer;
import io.github.daniloarcidiacono.typescript.mapper.resolver.CompositeUriResolver;
import io.github.daniloarcidiacono.typescript.mapper.resolver.UriResolver;
import io.github.daniloarcidiacono.typescript.template.TypescriptStringBuilder;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Renderer used for tests.
 * @author Danilo Arcidiacono
 */
public class TypescriptTestRenderer implements TypescriptRenderer {
    private CompositeUriResolver fileResolver = new CompositeUriResolver();
    private Map<URI, TypescriptStringBuilder> result = new HashMap<>();

    public TypescriptTestRenderer() {
    }

    public TypescriptTestRenderer resolver(final UriResolver resolver) {
        fileResolver.resolver(resolver);
        return this;
    }

    public TypescriptTestRenderer resolver(final UriResolver...resolvers) {
        fileResolver.resolver(resolvers);
        return this;
    }

    @Override
    public void render(final Collection<TypescriptMapped> mapped) {
        final Map<URI, List<TypescriptMapped>> distributed = fileResolver.distribute(mapped);
        for (URI path : distributed.keySet()) {
            result.put(path, new TypescriptStringBuilder());
        }

        for (URI path : distributed.keySet()) {
            final TypescriptStringBuilder sb = result.get(path);

            // Render
            final List<TypescriptMapped> pathDeclarations = distributed.get(path);
            pathDeclarations.sort(new TypescriptMappedComparator());

            PREAMBLE.render(sb);
            int index = 0;
            for (TypescriptMapped declaration : pathDeclarations) {
                declaration.getDeclaration().render(sb);
                if (index + 1 < pathDeclarations.size()) {
                    sb.appendln();
                }

                index++;
            }
        }
    }

    /**
     * Checks that the folder structure matches the one generated by the renderer.
     * @param path the path (in resources folder) of the base folder to compare.
     * @throws Exception
     */
    public void assertMatches(final String path) throws Exception {
        final Path folder = Paths.get(
            TypescriptTestRenderer.class.getClassLoader().getResource(path).toURI()
        );

        Files.walkFileTree(folder, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
            try {
                final URI relativePath = new URI(folder.relativize(file).toString());
                assertTrue(result.containsKey(relativePath), "Expected to find " + relativePath);

                final String resourcePath = Paths.get(path, relativePath.toString()).toString();
                final String resource = FileCommons.loadResource(resourcePath);
                assertEquals(resource, result.get(relativePath).toString());
                return FileVisitResult.CONTINUE;
            } catch (URISyntaxException e) {
                throw new IOException(e);
            }
            }
        });
    }
}
